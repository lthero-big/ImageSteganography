# 隐写与隐写提取

## 等待补充


# 实现步骤[概述]
1. 读取图片和密钥，并得到图片对应的像素bit信息；
2. 读入要隐写的信息，加密后转为2进制；
3. 找到能写入信息的一个像素位置
4. 将二进制的隐写信息写入到这个像素位置的最后一位，并重复3~4步骤直到写入完全部信息
5. 保存并生成新图片。


# 实现步骤[详细]
## 读入图片与密钥
将读入的图片进行格式转换，得到一个一维列表，每个列表元素是四元组，表示rgba()值。
## 读入隐写信息
如果用户输入了自定义密钥，我们将通过SJCL库调用函数，使用AES-128算法将二进制数据进行加密。如果用户不选择使用密钥，则我们使用SJCL库调用PBKDF2算法，并对明文迭代1000次进行加密保护。再将加密后的信息转成Unicode码，保证每个码是16位，方便后继的计算与提取。转Unicode码完成后，再转成二进制数据并保存。
## 找能写入的像素位置
最简单的编码方法是从左上角的像素开始对消息进行线性编码。不过这容易被编程方式和肉眼检测。所以需要将密文信息隐写在图片的各处，并且要让隐写过程可逆。

我采用sha-256算法，借助用户输入的密钥得到一个hash值，利用此hash值来计算密文将被插入到的每个起点位置，只要保证根据当前hash值算出的这个计算的结果是唯一的，那么这个hash值就也能用来解出隐写的内容。修改每个被选中的像素点的RGB像素点的最低位，从而隐写信息。
### 具体步骤如下
1. 计算出的Hash值长度为256位，并且按每32位一组被存放在一个长度为8的数组中。
2. 由于可能存在位置上的碰撞，所以用数组记录所有被隐写位置，同时为了减少碰撞，用当前被隐写位置和Hash值同时计算下一个隐写位置：
𝒂𝒃𝒔(𝒉𝒂𝒔𝒉[𝒑𝒐𝒔 % 𝒉𝒂𝒔𝒉.𝒍𝒆𝒏𝒈𝒕𝒉] ∗ (𝒑𝒐𝒔 + 𝟏)) % 𝒕𝒐𝒕𝒂𝒍
3. 判断第二步计算出的隐写位置与之前的位置是否有冲突，若有冲突则下标加1。
4. 在四通道RGBA中，我们只将数据隐写到RGB这三个通道中，A通道不隐写信息，如果（loc+1）%4 为0，我们也视作为冲突。
## 将信息写入像素最后一位
根据第二步保存的数据，逐个写入到第三步得到的像素位置的最后一位。
## 生成隐写图像
利用canvas提供的函数，将由像素组成的一维列表转成图片并保存
